import matplotlib.pyplot as plt
from matplotlib import gridspec
from mpl_toolkits.mplot3d import proj3d
from matplotlib.patches import FancyArrowPatch
import autograd.numpy as np
import math
from mpl_toolkits.mplot3d import Axes3D


class Visualizer:
    """
    Illustrate a run of your preferred optimization algorithm on a one or two-input function.  Run
    the algorithm first, and input the resulting weight history into this wrapper.
    """

    ##### draw picture of function and run for single-input function ####
    def single_input_plot(self, g, weight_histories, cost_histories, **kwargs):
        # adjust viewing range
        wmin = -3.1
        wmax = 3.1
        if "wmin" in kwargs:
            wmin = kwargs["wmin"]
        if "wmax" in kwargs:
            wmax = kwargs["wmax"]

        onerun_perplot = False
        if "onerun_perplot" in kwargs:
            onerun_perplot = kwargs["onerun_perplot"]

        ### initialize figure
        fig = plt.figure(figsize=(9, 4))
        artist = fig

        # remove whitespace from figure
        # fig.subplots_adjust(left=0, right=1, bottom=0, top=1) # remove whitespace
        # fig.subplots_adjust(wspace=0.01,hspace=0.01)

        # create subplot with 2 panels, plot input function in center plot
        gs = gridspec.GridSpec(1, 2, width_ratios=[1, 1])
        ax1 = plt.subplot(gs[0])
        ax2 = plt.subplot(gs[1])
        ### plot function in both panels
        w_plot = np.linspace(wmin, wmax, 500)
        g_plot = g(w_plot)
        gmin = np.min(g_plot)
        gmax = np.max(g_plot)
        g_range = gmax - gmin
        ggap = g_range * 0.1
        gmin -= ggap
        gmax += ggap

        # plot function, axes lines
        ax1.plot(w_plot, g_plot, color="k", zorder=2)  # plot function
        ax1.axhline(y=0, color="k", zorder=1, linewidth=0.25)
        ax1.axvline(x=0, color="k", zorder=1, linewidth=0.25)
        ax1.set_xlabel(r"$w$", fontsize=13)
        ax1.set_ylabel(r"$g(w)$", fontsize=13, rotation=0, labelpad=25)
        ax1.set_xlim(wmin, wmax)
        ax1.set_ylim(gmin, gmax)

        ax2.plot(w_plot, g_plot, color="k", zorder=2)  # plot function
        ax2.axhline(y=0, color="k", zorder=1, linewidth=0.25)
        ax2.axvline(x=0, color="k", zorder=1, linewidth=0.25)
        ax2.set_xlabel(r"$w$", fontsize=13)
        ax2.set_ylabel(r"$g(w)$", fontsize=13, rotation=0, labelpad=25)
        ax2.set_xlim(wmin, wmax)
        ax2.set_ylim(gmin, gmax)

        #### loop over histories and plot each
        for j in range(len(weight_histories)):
            w_hist = weight_histories[j]
            c_hist = cost_histories[j]

            # colors for points --> green as the algorithm begins, yellow as it converges, red at final point
            s = np.linspace(0, 1, len(w_hist[: round(len(w_hist) / 2)]))
            s.shape = (len(s), 1)
            t = np.ones(len(w_hist[round(len(w_hist) / 2) :]))
            t.shape = (len(t), 1)
            s = np.vstack((s, t))
            self.colorspec = []
            self.colorspec = np.concatenate((s, np.flipud(s)), 1)
            self.colorspec = np.concatenate((self.colorspec, np.zeros((len(s), 1))), 1)

            ### plot all history points
            ax = ax2
            if onerun_perplot == True:
                if j == 0:
                    ax = ax1
                if j == 1:
                    ax = ax2
            for k in range(len(w_hist)):
                # pick out current weight and function value from history, then plot
                w_val = w_hist[k]
                g_val = c_hist[k]
                ax.scatter(
                    w_val, g_val, s=90, color=self.colorspec[k], edgecolor="k", linewidth=0.5 * (1 / (float(k) + 1)) ** (0.4), zorder=3, marker="X"
                )  # evaluation on function
                ax.scatter(w_val, 0, s=90, facecolor=self.colorspec[k], edgecolor="k", linewidth=0.5 * (1 / (float(k) + 1)) ** (0.4), zorder=3)

    ##### draw picture of function and run for two-input function ####
    def two_input_surface_contour_plot(self, g, w_hist, **kwargs):
        ### input arguments ###
        num_contours = 10
        if "num_contours" in kwargs:
            num_contours = kwargs["num_contours"]

        view = [20, 20]
        if "view" in kwargs:
            view = kwargs["view"]

        ##### construct figure with panels #####
        # construct figure
        fig = plt.figure(figsize=(11, 5))
        self.edgecolor = "k"

        # create subplot with 3 panels, plot input function in center plot
        # this seems to be the best option for whitespace management when using
        # both a surface and contour plot in the same figure
        gs = gridspec.GridSpec(1, 3, width_ratios=[1, 5, 10])
        ax1 = plt.subplot(gs[1], projection="3d")
        ax2 = plt.subplot(gs[2], aspect="equal")
        # remove whitespace from figure
        fig.subplots_adjust(left=0, right=1, bottom=0, top=1)  # remove whitespace
        fig.subplots_adjust(wspace=0.01, hspace=0.01)

        # plot 3d surface and path in left panel
        self.draw_surface(g, ax1, **kwargs)
        self.show_inputspace_path(w_hist, ax1)
        ax1.view_init(view[0], view[1])

        ### make contour right plot - as well as horizontal and vertical axes ###
        self.contour_plot_setup(g, ax2, **kwargs)  # draw contour plot
        self.draw_weight_path(ax2, w_hist)  # draw path on contour plot

        # plot
        plt.show()

    # compare cost histories from multiple runs
    def plot_cost_histories(self, histories, start, **kwargs):
        # plotting colors
        colors = ["k", "magenta", "aqua", "blueviolet", "chocolate"]

        # initialize figure
        fig = plt.figure(figsize=(10, 3))

        # create subplot with 1 panel
        gs = gridspec.GridSpec(1, 1)
        ax = plt.subplot(gs[0])
        # any labels to add?
        labels = [" ", " "]
        if "labels" in kwargs:
            labels = kwargs["labels"]

        # plot points on cost function plot too?
        points = False
        if "points" in kwargs:
            points = kwargs["points"]

        # run through input histories, plotting each beginning at 'start' iteration
        for c in range(len(histories)):
            history = histories[c]
            label = 0
            if c == 0:
                label = labels[0]
            else:
                label = labels[1]

            # check if a label exists, if so add it to the plot
            if np.size(label) == 0:
                ax.plot(np.arange(start, len(history), 1), history[start:], linewidth=3 * (0.8) ** (c), color=colors[c])
            else:
                ax.plot(np.arange(start, len(history), 1), history[start:], linewidth=3 * (0.8) ** (c), color=colors[c], label=label)

            # check if points should be plotted for visualization purposes
            if points == True:
                ax.scatter(np.arange(start, len(history), 1), history[start:], s=90, color=colors[c], edgecolor="w", linewidth=2, zorder=3)

        # clean up panel
        xlabel = "step $k$"
        if "xlabel" in kwargs:
            xlabel = kwargs["xlabel"]
        ylabel = r"$g\left(\mathbf{w}^k\right)$"
        if "ylabel" in kwargs:
            ylabel = kwargs["ylabel"]
        ax.set_xlabel(xlabel, fontsize=14)
        ax.set_ylabel(ylabel, fontsize=14, rotation=0, labelpad=25)
        if np.size(label) > 0:
            anchor = (1, 1)
            if "anchor" in kwargs:
                anchor = kwargs["anchor"]
            plt.legend(loc="upper right", bbox_to_anchor=anchor)
            # leg = ax.legend(loc='upper left', bbox_to_anchor=(1.02, 1), borderaxespad=0)

        ax.set_xlim([start - 0.5, len(history) - 0.5])

        # fig.tight_layout()
        plt.show()

    ########################################################################################
    #### utility functions - for setting up / making contour plots, 3d surface plots, etc., ####
    # show contour plot of input function
    def contour_plot_setup(self, g, ax, **kwargs):
        xmin = -3.1
        xmax = 3.1
        ymin = -3.1
        ymax = 3.1
        if "xmin" in kwargs:
            xmin = kwargs["xmin"]
        if "xmax" in kwargs:
            xmax = kwargs["xmax"]
        if "ymin" in kwargs:
            ymin = kwargs["ymin"]
        if "ymax" in kwargs:
            ymax = kwargs["ymax"]
        num_contours = 20
        if "num_contours" in kwargs:
            num_contours = kwargs["num_contours"]

        # choose viewing range using weight history?
        if "view_by_weights" in kwargs:
            view_by_weights = True
            weight_history = kwargs["weight_history"]
            if view_by_weights == True:
                xmin = min([v[0] for v in weight_history])[0]
                xmax = max([v[0] for v in weight_history])[0]
                xgap = (xmax - xmin) * 0.25
                xmin -= xgap
                xmax += xgap

                ymin = min([v[1] for v in weight_history])[0]
                ymax = max([v[1] for v in weight_history])[0]
                ygap = (ymax - ymin) * 0.25
                ymin -= ygap
                ymax += ygap

        ### plot function as contours ###
        self.draw_contour_plot(g, ax, num_contours, xmin, xmax, ymin, ymax)

        ### cleanup panel ###
        ax.set_xlabel("$w_0$", fontsize=14)
        ax.set_ylabel("$w_1$", fontsize=14, labelpad=15, rotation=0)
        ax.axhline(y=0, color="k", zorder=0, linewidth=0.5)
        ax.axvline(x=0, color="k", zorder=0, linewidth=0.5)
        # ax.set_xticks(np.arange(round(xmin),round(xmax)+1))
        # ax.set_yticks(np.arange(round(ymin),round(ymax)+1))

        # set viewing limits
        ax.set_xlim(xmin, xmax)
        ax.set_ylim(ymin, ymax)

    ### function for creating contour plot
    def draw_contour_plot(self, g, ax, num_contours, xmin, xmax, ymin, ymax):
        #### define input space for function and evaluate ####
        w1 = np.linspace(xmin, xmax, 400)
        w2 = np.linspace(ymin, ymax, 400)
        w1_vals, w2_vals = np.meshgrid(w1, w2)
        w1_vals.shape = (len(w1) ** 2, 1)
        w2_vals.shape = (len(w2) ** 2, 1)
        h = np.concatenate((w1_vals, w2_vals), axis=1)
        func_vals = np.asarray([g(np.reshape(s, (2, 1))) for s in h])

        w1_vals.shape = (len(w1), len(w1))
        w2_vals.shape = (len(w2), len(w2))
        func_vals.shape = (len(w1), len(w2))

        ### make contour right plot - as well as horizontal and vertical axes ###
        # set level ridges
        levelmin = min(func_vals.flatten())
        levelmax = max(func_vals.flatten())
        cutoff = 1
        cutoff = (levelmax - levelmin) * cutoff
        numper = 4
        levels1 = np.linspace(cutoff, levelmax, numper)
        num_contours -= numper

        # produce generic contours
        levels2 = np.linspace(levelmin, cutoff, min(num_contours, numper))
        levels = np.unique(np.append(levels1, levels2))
        num_contours -= numper
        while num_contours > 0:
            cutoff = levels[1]
            levels2 = np.linspace(levelmin, cutoff, min(num_contours, numper))
            levels = np.unique(np.append(levels2, levels))
            num_contours -= numper

        # plot the contours
        ax.contour(w1_vals, w2_vals, func_vals, levels=levels[1:], colors="k")
        ax.contourf(w1_vals, w2_vals, func_vals, levels=levels, cmap="Blues")

        ###### clean up plot ######
        ax.set_xlabel("$w_0$", fontsize=12)
        ax.set_ylabel("$w_1$", fontsize=12, rotation=0)
        ax.axhline(y=0, color="k", zorder=0, linewidth=0.5)
        ax.axvline(x=0, color="k", zorder=0, linewidth=0.5)

    ### makes color spectrum for plotted run points - from green (start) to red (stop)
    def make_colorspec(self, w_hist):
        # make color range for path
        s = np.linspace(0, 1, len(w_hist[: round(len(w_hist) / 2)]))
        s.shape = (len(s), 1)
        t = np.ones(len(w_hist[round(len(w_hist) / 2) :]))
        t.shape = (len(t), 1)
        s = np.vstack((s, t))
        colorspec = []
        colorspec = np.concatenate((s, np.flipud(s)), 1)
        colorspec = np.concatenate((colorspec, np.zeros((len(s), 1))), 1)
        return colorspec

    ### function for drawing weight history path
    def draw_weight_path(self, ax, w_hist, **kwargs):
        # make colors for plot
        colorspec = self.make_colorspec(w_hist)

        arrows = True
        if "arrows" in kwargs:
            arrows = kwargs["arrows"]

        ### plot function decrease plot in right panel
        for j in range(len(w_hist)):
            w_val = w_hist[j]

            # plot each weight set as a point
            ax.scatter(
                w_val[0], w_val[1], s=80, color=colorspec[j], edgecolor=self.edgecolor, linewidth=2 * math.sqrt((1 / (float(j) + 1))), zorder=3
            )

            # plot connector between points for visualization purposes
            if j > 0:
                pt1 = w_hist[j - 1]
                pt2 = w_hist[j]

                # produce scalar for arrow head length
                pt_length = np.linalg.norm(pt1 - pt2)
                head_length = 0.1
                alpha = (head_length - 0.35) / pt_length + 1

                # if points are different draw error
                if np.linalg.norm(pt1 - pt2) > head_length and arrows == True:
                    if np.ndim(pt1) > 1:
                        pt1 = pt1.flatten()
                        pt2 = pt2.flatten()

                    # draw color connectors for visualization
                    w_old = pt1
                    w_new = pt2
                    ax.plot([w_old[0], w_new[0]], [w_old[1], w_new[1]], color=colorspec[j], linewidth=2, alpha=1, zorder=2)  # plot approx
                    ax.plot([w_old[0], w_new[0]], [w_old[1], w_new[1]], color="k", linewidth=3, alpha=1, zorder=1)  # plot approx

                    # draw arrows connecting pairwise points
                    # ax.arrow(pt1[0],pt1[1],(pt2[0] - pt1[0])*alpha,(pt2[1] - pt1[1])*alpha, head_width=0.1, head_length=head_length, fc='k', ec='k',linewidth=4,zorder = 2,length_includes_head=True)
                    # ax.arrow(pt1[0],pt1[1],(pt2[0] - pt1[0])*alpha,(pt2[1] - pt1[1])*alpha, head_width=0.1, head_length=head_length, fc='w', ec='w',linewidth=0.25,zorder = 2,length_includes_head=True)

    ### draw surface plot
    def draw_surface(self, g, ax, **kwargs):
        xmin = -3.1
        xmax = 3.1
        ymin = -3.1
        ymax = 3.1
        if "xmin" in kwargs:
            xmin = kwargs["xmin"]
        if "xmax" in kwargs:
            xmax = kwargs["xmax"]
        if "ymin" in kwargs:
            ymin = kwargs["ymin"]
        if "ymax" in kwargs:
            ymax = kwargs["ymax"]

        #### define input space for function and evaluate ####
        w1 = np.linspace(xmin, xmax, 200)
        w2 = np.linspace(ymin, ymax, 200)
        w1_vals, w2_vals = np.meshgrid(w1, w2)
        w1_vals.shape = (len(w1) ** 2, 1)
        w2_vals.shape = (len(w2) ** 2, 1)
        h = np.concatenate((w1_vals, w2_vals), axis=1)
        func_vals = np.asarray([g(np.reshape(s, (2, 1))) for s in h])

        ### plot function as surface ###
        w1_vals.shape = (len(w1), len(w2))
        w2_vals.shape = (len(w1), len(w2))
        func_vals.shape = (len(w1), len(w2))
        ax.plot_surface(w1_vals, w2_vals, func_vals, alpha=0.1, color="w", rstride=25, cstride=25, linewidth=1, edgecolor="k", zorder=2)

        # plot z=0 plane
        ax.plot_surface(w1_vals, w2_vals, func_vals * 0, alpha=0.1, color="w", zorder=1, rstride=25, cstride=25, linewidth=0.3, edgecolor="k")

        # clean up axis
        ax.xaxis.pane.fill = False
        ax.yaxis.pane.fill = False
        ax.zaxis.pane.fill = False

        ax.xaxis.pane.set_edgecolor("white")
        ax.yaxis.pane.set_edgecolor("white")
        ax.zaxis.pane.set_edgecolor("white")

        ax.xaxis._axinfo["grid"]["color"] = (1, 1, 1, 0)
        ax.yaxis._axinfo["grid"]["color"] = (1, 1, 1, 0)
        ax.zaxis._axinfo["grid"]["color"] = (1, 1, 1, 0)

        ax.set_xlabel("$w_0$", fontsize=14)
        ax.set_ylabel("$w_1$", fontsize=14, rotation=0)
        ax.set_title("$g(w_0,w_1)$", fontsize=14)

    ### plot points and connectors in input space in 3d plot
    def show_inputspace_path(self, w_hist, ax):
        # make colors for plot
        colorspec = self.make_colorspec(w_hist)

        for k in range(len(w_hist)):
            pt1 = w_hist[k]
            ax.scatter(pt1[0], pt1[1], 0, s=60, color=colorspec[k], edgecolor="k", linewidth=0.5 * math.sqrt((1 / (float(k) + 1))), zorder=3)
            if k < len(w_hist) - 1:
                pt2 = w_hist[k + 1]
                if np.linalg.norm(pt1 - pt2) > 10 ** (-3):
                    # draw arrow in left plot
                    a = Arrow3D([pt1[0], pt2[0]], [pt1[1], pt2[1]], [0, 0], mutation_scale=10, lw=2, arrowstyle="-|>", color="k")
                    ax.add_artist(a)


# animator for random local search
def visualize3d(func, pt_history, eval_history, **kwargs):
    ### input arguments ###
    wmax = 1
    if "wmax" in kwargs:
        wmax = kwargs["wmax"] + 0.5

    view = [20, -50]
    if "view" in kwargs:
        view = kwargs["view"]

    axes = False
    if "axes" in kwargs:
        axes = kwargs["axes"]

    plot_final = False
    if "plot_final" in kwargs:
        plot_final = kwargs["plot_final"]

    num_contours = 10
    if "num_contours" in kwargs:
        num_contours = kwargs["num_contours"]

    pt = [0, 0]
    if "pt" in kwargs:
        pt = kwargs["pt"]
    pt = np.asarray(pt)
    pt.shape = (2, 1)

    max_steps = 10
    if "max_steps" in kwargs:
        max_steps = kwargs["max_steps"]
    num_samples = 10
    if "num_samples" in kwargs:
        num_samples = kwargs["num_samples"]
    steplength = 1
    if "steplength" in kwargs:
        steplength = kwargs["steplength"]

    ##### construct figure with panels #####
    # construct figure
    fig = plt.figure(figsize=(9, 3))

    # remove whitespace from figure
    fig.subplots_adjust(left=0, right=1, bottom=0, top=1)  # remove whitespace

    # create subplot with 3 panels, plot input function in center plot
    gs = gridspec.GridSpec(1, 2, width_ratios=[1, 2])
    ax = plt.subplot(gs[0], projection="3d")
    ax2 = plt.subplot(gs[1], aspect="equal")
    #### define input space for function and evaluate ####
    w = np.linspace(-wmax, wmax, 200)
    w1_vals, w2_vals = np.meshgrid(w, w)
    w1_vals.shape = (len(w) ** 2, 1)
    w2_vals.shape = (len(w) ** 2, 1)
    h = np.concatenate((w1_vals, w2_vals), axis=1)
    func_vals = np.asarray([func(s) for s in h])
    w1_vals.shape = (len(w), len(w))
    w2_vals.shape = (len(w), len(w))
    func_vals.shape = (len(w), len(w))

    # plot function
    ax.plot_surface(w1_vals, w2_vals, func_vals, alpha=0.1, color="w", rstride=25, cstride=25, linewidth=1, edgecolor="k", zorder=2)

    # plot z=0 plane
    ax.plot_surface(w1_vals, w2_vals, func_vals * 0, alpha=0.1, color="w", zorder=1, rstride=25, cstride=25, linewidth=0.3, edgecolor="k")

    ### make contour right plot - as well as horizontal and vertical axes ###
    ax2.contour(w1_vals, w2_vals, func_vals, num_contours, colors="k")
    if axes == True:
        ax2.axhline(linestyle="--", color="k", linewidth=1)
        ax2.axvline(linestyle="--", color="k", linewidth=1)

    ### plot circle on which point lies, as well as step length circle - used only for simple quadratic
    if plot_final == True:
        # plot contour of quadratic on which final point was plotted
        f = pt_history[-1]
        val = np.linalg.norm(f)
        theta = np.linspace(0, 1, 400)
        x = val * np.cos(2 * np.pi * theta)
        y = val * np.sin(2 * np.pi * theta)
        ax2.plot(x, y, color="r", linestyle="--", linewidth=1)

        # plot direction sampling circle centered at final point
        x = steplength * np.cos(2 * np.pi * theta) + f[0]
        y = steplength * np.sin(2 * np.pi * theta) + f[1]
        ax2.plot(x, y, color="b", linewidth=1)

    # colors for points
    s = np.linspace(0, 1, len(eval_history[: round(len(eval_history) / 2)]))
    s.shape = (len(s), 1)
    t = np.ones(len(eval_history[round(len(eval_history) / 2) :]))
    t.shape = (len(t), 1)
    s = np.vstack((s, t))
    colorspec = []
    colorspec = np.concatenate((s, np.flipud(s)), 1)
    colorspec = np.concatenate((colorspec, np.zeros((len(s), 1))), 1)

    #### scatter path points ####
    for k in range(len(eval_history)):
        ax.scatter(
            pt_history[k][0], pt_history[k][1], 0, s=60, color=colorspec[k], edgecolor="k", linewidth=0.5 * math.sqrt((1 / (float(k) + 1))), zorder=3
        )

        ax2.scatter(
            pt_history[k][0], pt_history[k][1], s=60, color=colorspec[k], edgecolor="k", linewidth=1.5 * math.sqrt((1 / (float(k) + 1))), zorder=3
        )

    #### connect points with arrows ####
    for i in range(len(eval_history) - 1):
        pt1 = pt_history[i]
        pt2 = pt_history[i + 1]

        if np.linalg.norm(pt1 - pt2) > 0.5:
            # draw arrow in left plot
            a = Arrow3D([pt1[0], pt2[0]], [pt1[1], pt2[1]], [0, 0], mutation_scale=10, lw=2, arrowstyle="-|>", color="k")
            ax.add_artist(a)

            # draw 2d arrow in right plot
            ax2.arrow(
                pt1[0],
                pt1[1],
                (pt2[0] - pt1[0]) * 0.78,
                (pt2[1] - pt1[1]) * 0.78,
                head_width=0.1,
                head_length=0.1,
                fc="k",
                ec="k",
                linewidth=3,
                zorder=2,
                length_includes_head=True,
            )

    ### cleanup panels ###
    ax.set_xlabel("$w_0$", fontsize=12)
    ax.set_ylabel("$w_1$", fontsize=12, rotation=0)
    ax.set_title("$g(w_0,w_1)$", fontsize=12)
    ax.view_init(view[0], view[1])

    ax2.set_xlabel("$w_0$", fontsize=12)
    ax2.set_ylabel("$w_1$", fontsize=12, rotation=0)

    # clean up axis
    ax.xaxis.pane.fill = False
    ax.yaxis.pane.fill = False
    ax.zaxis.pane.fill = False

    ax.xaxis.pane.set_edgecolor("white")
    ax.yaxis.pane.set_edgecolor("white")
    ax.zaxis.pane.set_edgecolor("white")

    ax.xaxis._axinfo["grid"]["color"] = (1, 1, 1, 0)
    ax.yaxis._axinfo["grid"]["color"] = (1, 1, 1, 0)
    ax.zaxis._axinfo["grid"]["color"] = (1, 1, 1, 0)

    # plot
    plt.show()


#### custom 3d arrow and annotator functions ###
# nice arrow maker from https://stackoverflow.com/questions/11140163/python-matplotlib-plotting-a-3d-cube-a-sphere-and-a-vector
class Arrow3D(FancyArrowPatch):
    def __init__(self, xs, ys, zs, *args, **kwargs):
        super().__init__((0, 0), (0, 0), *args, **kwargs)
        self._verts3d = xs, ys, zs

    def do_3d_projection(self, renderer=None):
        xs3d, ys3d, zs3d = self._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)
        self.set_positions((xs[0], ys[0]), (xs[1], ys[1]))

        return np.min(zs)

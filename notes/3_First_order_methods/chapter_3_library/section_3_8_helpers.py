import matplotlib.pyplot as plt
from matplotlib import gridspec
from matplotlib.ticker import FormatStrFormatter
import matplotlib.animation as animation
from mpl_toolkits.mplot3d import Axes3D
from IPython.display import clear_output
from mpl_toolkits.mplot3d import proj3d
from matplotlib.patches import FancyArrowPatch
from matplotlib.text import Annotation
from mpl_toolkits.mplot3d.proj3d import proj_transform
import numpy as np
from autograd import grad as compute_grad
import math
import time


class exponential_visualizer:
    """
    animators for time series
    """

    #### animate exponential average ####
    def animate_exponential_ave(self, x, y, savepath, **kwargs):
        # produce figure
        fig = plt.figure(figsize=(9, 4))
        gs = gridspec.GridSpec(1, 3, width_ratios=[1, 7, 1])
        ax = plt.subplot(gs[0])
        ax.axis("off")
        ax1 = plt.subplot(gs[1])
        ax2 = plt.subplot(gs[2])
        ax2.axis("off")
        artist = fig

        # view limits
        xmin = -3
        xmax = len(x) + 3
        ymin = np.min(x)
        ymax = np.max(x)
        ygap = (ymax - ymin) * 0.15
        ymin -= ygap
        ymax += ygap

        # start animation
        num_frames = len(y)
        print("starting animation rendering...")

        def animate(k):
            # clear panels
            ax1.cla()

            # print rendering update
            if np.mod(k + 1, 25) == 0:
                print("rendering animation frame " + str(k + 1) + " of " + str(num_frames))
            if k == num_frames - 1:
                print("animation rendering complete!")
                time.sleep(1.5)
                clear_output()

            # plot x
            ax1.plot(np.arange(1, x.size + 1), x, alpha=1, color="k", linewidth=2, zorder=2)
            # plot exponential average - initial conditions
            if k == 1:
                ax1.plot(np.arange(1, 2), y[:1], alpha=0.75, c="darkorange", linewidth=4, zorder=3)

            # plot moving average - everything after and including initial conditions
            if k > 1:
                # plot
                ax1.plot(np.arange(1, k + 1), y[:k], alpha=0.7, color="darkorange", linewidth=4, zorder=3)

            # label axes
            ax1.set_xlim([xmin, xmax])
            ax1.set_ylim([ymin, ymax])
            return (artist,)

        anim = animation.FuncAnimation(fig, animate, frames=num_frames, interval=num_frames, blit=True)

        # produce animation and save
        fps = 50
        if "fps" in kwargs:
            fps = kwargs["fps"]
        anim.save(savepath, fps=fps, extra_args=["-vcodec", "libx264"])
        clear_output()


class static_visualizer:
    """
    Illustrate a run of your preferred optimization algorithm on a one or two-input function.  Run
    the algorithm first, and input the resulting weight history into this wrapper.
    """

    ##### draw picture of function and run for two-input function ####
    def two_input_contour_vert_plots(self, gs, histories, **kwargs):
        ##### construct figure with panels #####
        # construct figure
        fig = plt.figure(figsize=(10, 7))

        # create figure with single plot for contour
        num_plots = len(histories)
        axs = gridspec.GridSpec(num_plots, 1)

        # remove whitespace from figure
        fig.subplots_adjust(left=0, right=1, bottom=0, top=1)  # remove whitespace
        fig.subplots_adjust(wspace=0.01, hspace=0.01)

        # define edgecolors
        edgecolors = ["k", "k", "k", "k", "k"]

        # loop over histories and plot
        for j in range(num_plots):
            # get next weight history
            w_hist = histories[j]
            g = gs[j]

            # create subplot
            ax = plt.subplot(axs[j], aspect="equal")
            ### make contour right plot - as well as horizontal and vertical axes ###
            self.contour_plot_setup(g, ax, **kwargs)  # draw contour plot
            self.edgecolor = edgecolors[j]
            self.draw_weight_path(ax, w_hist, **kwargs)  # draw path on contour plot

        # plot
        plt.show()

    ########################################################################################
    #### utility functions - for setting up / making contour plots, 3d surface plots, etc., ####
    # show contour plot of input function
    def contour_plot_setup(self, g, ax, **kwargs):
        xmin = -3.1
        xmax = 3.1
        ymin = -3.1
        ymax = 3.1
        if "xmin" in kwargs:
            xmin = kwargs["xmin"]
        if "xmax" in kwargs:
            xmax = kwargs["xmax"]
        if "ymin" in kwargs:
            ymin = kwargs["ymin"]
        if "ymax" in kwargs:
            ymax = kwargs["ymax"]
        num_contours = 20
        if "num_contours" in kwargs:
            num_contours = kwargs["num_contours"]

        # choose viewing range using weight history?
        if "view_by_weights" in kwargs:
            view_by_weights = True
            weight_history = kwargs["weight_history"]
            if view_by_weights == True:
                xmin = min([v[0] for v in weight_history])[0]
                xmax = max([v[0] for v in weight_history])[0]
                xgap = (xmax - xmin) * 0.25
                xmin -= xgap
                xmax += xgap

                ymin = min([v[1] for v in weight_history])[0]
                ymax = max([v[1] for v in weight_history])[0]
                ygap = (ymax - ymin) * 0.25
                ymin -= ygap
                ymax += ygap

        ### plot function as contours ###
        self.draw_contour_plot(g, ax, num_contours, xmin, xmax, ymin, ymax)

        ### cleanup panel ###
        ax.set_xlabel("$w_0$", fontsize=14)
        ax.set_ylabel("$w_1$", fontsize=14, labelpad=15, rotation=0)
        ax.axhline(y=0, color="k", zorder=0, linewidth=0.5)
        ax.axvline(x=0, color="k", zorder=0, linewidth=0.5)
        # ax.set_xticks(np.arange(round(xmin),round(xmax)+1))
        # ax.set_yticks(np.arange(round(ymin),round(ymax)+1))

        # set viewing limits
        ax.set_xlim(xmin, xmax)
        ax.set_ylim(ymin, ymax)

    ### function for creating contour plot
    def draw_contour_plot(self, g, ax, num_contours, xmin, xmax, ymin, ymax):
        #### define input space for function and evaluate ####
        w1 = np.linspace(xmin, xmax, 400)
        w2 = np.linspace(ymin, ymax, 400)
        w1_vals, w2_vals = np.meshgrid(w1, w2)
        w1_vals.shape = (len(w1) ** 2, 1)
        w2_vals.shape = (len(w2) ** 2, 1)
        h = np.concatenate((w1_vals, w2_vals), axis=1)
        func_vals = np.asarray([g(np.reshape(s, (2, 1))) for s in h])

        w1_vals.shape = (len(w1), len(w1))
        w2_vals.shape = (len(w2), len(w2))
        func_vals.shape = (len(w1), len(w2))

        ### make contour right plot - as well as horizontal and vertical axes ###
        # set level ridges
        levelmin = min(func_vals.flatten())
        levelmax = max(func_vals.flatten())
        cutoff = 1
        cutoff = (levelmax - levelmin) * cutoff
        numper = 4
        levels1 = np.linspace(cutoff, levelmax, numper)
        num_contours -= numper

        # produce generic contours
        levels2 = np.linspace(levelmin, cutoff, min(num_contours, numper))
        levels = np.unique(np.append(levels1, levels2))
        num_contours -= numper
        while num_contours > 0:
            cutoff = levels[1]
            levels2 = np.linspace(levelmin, cutoff, min(num_contours, numper))
            levels = np.unique(np.append(levels2, levels))
            num_contours -= numper

        # plot the contours
        ax.contour(w1_vals, w2_vals, func_vals, levels=levels[1:], colors="k")
        ax.contourf(w1_vals, w2_vals, func_vals, levels=levels, cmap="Blues")

        ###### clean up plot ######
        ax.set_xlabel("$w_0$", fontsize=12)
        ax.set_ylabel("$w_1$", fontsize=12, rotation=0)
        ax.axhline(y=0, color="k", zorder=0, linewidth=0.5)
        ax.axvline(x=0, color="k", zorder=0, linewidth=0.5)

    ### makes color spectrum for plotted run points - from green (start) to red (stop)
    def make_colorspec(self, w_hist):
        # make color range for path
        s = np.linspace(0, 1, len(w_hist[: round(len(w_hist) / 2)]))
        s.shape = (len(s), 1)
        t = np.ones(len(w_hist[round(len(w_hist) / 2) :]))
        t.shape = (len(t), 1)
        s = np.vstack((s, t))
        colorspec = []
        colorspec = np.concatenate((s, np.flipud(s)), 1)
        colorspec = np.concatenate((colorspec, np.zeros((len(s), 1))), 1)
        return colorspec

    ### function for drawing weight history path
    def draw_grads(self, ax, directions, **kwargs):
        # make colors for plot
        colorspec = self.make_colorspec(directions)

        arrows = True
        if "arrows" in kwargs:
            arrows = kwargs["arrows"]

        # plot axes
        ax.axhline(y=0, color="k", zorder=0, linewidth=0.5)
        ax.axvline(x=0, color="k", zorder=0, linewidth=0.5)

        ### plot function decrease plot in right panel
        for j in range(len(directions)):
            # get current direction
            direction = directions[j]

            # draw arrows connecting pairwise points
            head_length = 0.1
            head_width = 0.1
            ax.arrow(
                0,
                0,
                direction[0],
                direction[1],
                head_width=head_width,
                head_length=head_length,
                fc="k",
                ec="k",
                linewidth=1,
                zorder=2,
                length_includes_head=True,
            )
            ax.arrow(
                0,
                0,
                direction[0],
                direction[1],
                head_width=0.1,
                head_length=head_length,
                fc=colorspec[j],
                ec=colorspec[j],
                linewidth=0.25,
                zorder=2,
                length_includes_head=True,
            )

    ### function for drawing weight history path
    def draw_grads_v2(self, ax, directions, **kwargs):
        arrows = True
        if "arrows" in kwargs:
            arrows = kwargs["arrows"]

        # plot axes
        ax.axhline(y=0, color="k", zorder=0, linewidth=0.5)
        ax.axvline(x=0, color="k", zorder=0, linewidth=0.5)

        ### plot function decrease plot in right panel
        head_length = 0.1
        head_width = 0.1
        alpha = 0.1
        for j in range(len(directions) - 1):
            # get current direction
            direction = directions[j]

            # draw arrows connecting pairwise points
            ax.arrow(
                0,
                0,
                direction[0],
                direction[1],
                head_width=head_width,
                head_length=head_length,
                fc="k",
                ec="k",
                linewidth=3.5,
                zorder=2,
                length_includes_head=True,
                alpha=alpha,
            )
            ax.arrow(
                0,
                0,
                direction[0],
                direction[1],
                head_width=0.1,
                head_length=head_length,
                fc=self.colorspec[j],
                ec=self.colorspec[j],
                linewidth=3,
                zorder=2,
                length_includes_head=True,
                alpha=alpha,
            )

        # plot most recent direction
        direction = directions[-1]
        num_dirs = len(directions)

        # draw arrows connecting pairwise points
        ax.arrow(
            0,
            0,
            direction[0],
            direction[1],
            head_width=head_width,
            head_length=head_length,
            fc="k",
            ec="k",
            linewidth=4,
            zorder=2,
            length_includes_head=True,
        )
        ax.arrow(
            0,
            0,
            direction[0],
            direction[1],
            head_width=0.1,
            head_length=head_length,
            fc=self.colorspec[num_dirs],
            ec=self.colorspec[num_dirs],
            linewidth=3,
            zorder=2,
            length_includes_head=True,
        )

    ### function for drawing weight history path
    def draw_weight_path(self, ax, w_hist, **kwargs):
        # make colors for plot
        colorspec = self.make_colorspec(w_hist)

        arrows = True
        if "arrows" in kwargs:
            arrows = kwargs["arrows"]

        ### plot function decrease plot in right panel
        for j in range(len(w_hist)):
            w_val = w_hist[j]

            # plot each weight set as a point
            ax.scatter(
                w_val[0], w_val[1], s=80, color=colorspec[j], edgecolor=self.edgecolor, linewidth=2 * math.sqrt((1 / (float(j) + 1))), zorder=3
            )

            # plot connector between points for visualization purposes
            if j > 0:
                pt1 = w_hist[j - 1]
                pt2 = w_hist[j]

                # produce scalar for arrow head length
                pt_length = np.linalg.norm(pt1 - pt2)
                head_length = 0.1
                alpha = (head_length - 0.35) / pt_length + 1

                # if points are different draw error
                if np.linalg.norm(pt1 - pt2) > head_length and arrows == True:
                    if np.ndim(pt1) > 1:
                        pt1 = pt1.flatten()
                        pt2 = pt2.flatten()

                    # draw color connectors for visualization
                    w_old = pt1
                    w_new = pt2
                    ax.plot([w_old[0], w_new[0]], [w_old[1], w_new[1]], color=colorspec[j], linewidth=2, alpha=1, zorder=2)  # plot approx
                    ax.plot([w_old[0], w_new[0]], [w_old[1], w_new[1]], color="k", linewidth=3, alpha=1, zorder=1)  # plot approx

                    # draw arrows connecting pairwise points
                    # ax.arrow(pt1[0],pt1[1],(pt2[0] - pt1[0])*alpha,(pt2[1] - pt1[1])*alpha, head_width=0.1, head_length=head_length, fc='k', ec='k',linewidth=4,zorder = 2,length_includes_head=True)
                    # ax.arrow(pt1[0],pt1[1],(pt2[0] - pt1[0])*alpha,(pt2[1] - pt1[1])*alpha, head_width=0.1, head_length=head_length, fc='w', ec='w',linewidth=0.25,zorder = 2,length_includes_head=True)

    ### draw surface plot
    def draw_surface(self, g, ax, **kwargs):
        xmin = -3.1
        xmax = 3.1
        ymin = -3.1
        ymax = 3.1
        if "xmin" in kwargs:
            xmin = kwargs["xmin"]
        if "xmax" in kwargs:
            xmax = kwargs["xmax"]
        if "ymin" in kwargs:
            ymin = kwargs["ymin"]
        if "ymax" in kwargs:
            ymax = kwargs["ymax"]

        #### define input space for function and evaluate ####
        w1 = np.linspace(xmin, xmax, 200)
        w2 = np.linspace(ymin, ymax, 200)
        w1_vals, w2_vals = np.meshgrid(w1, w2)
        w1_vals.shape = (len(w1) ** 2, 1)
        w2_vals.shape = (len(w2) ** 2, 1)
        h = np.concatenate((w1_vals, w2_vals), axis=1)
        func_vals = np.asarray([g(np.reshape(s, (2, 1))) for s in h])

        ### plot function as surface ###
        w1_vals.shape = (len(w1), len(w2))
        w2_vals.shape = (len(w1), len(w2))
        func_vals.shape = (len(w1), len(w2))
        ax.plot_surface(w1_vals, w2_vals, func_vals, alpha=0.1, color="w", rstride=25, cstride=25, linewidth=1, edgecolor="k", zorder=2)

        # plot z=0 plane
        ax.plot_surface(w1_vals, w2_vals, func_vals * 0, alpha=0.1, color="w", zorder=1, rstride=25, cstride=25, linewidth=0.3, edgecolor="k")

        # clean up axis
        ax.xaxis.pane.fill = False
        ax.yaxis.pane.fill = False
        ax.zaxis.pane.fill = False

        ax.xaxis.pane.set_edgecolor("white")
        ax.yaxis.pane.set_edgecolor("white")
        ax.zaxis.pane.set_edgecolor("white")

        ax.xaxis._axinfo["grid"]["color"] = (1, 1, 1, 0)
        ax.yaxis._axinfo["grid"]["color"] = (1, 1, 1, 0)
        ax.zaxis._axinfo["grid"]["color"] = (1, 1, 1, 0)

        ax.set_xlabel("$w_0$", fontsize=14)
        ax.set_ylabel("$w_1$", fontsize=14, rotation=0)
        ax.set_title("$g(w_0,w_1)$", fontsize=14)

    ### plot points and connectors in input space in 3d plot
    def show_inputspace_path(self, w_hist, ax):
        # make colors for plot
        colorspec = self.make_colorspec(w_hist)

        for k in range(len(w_hist)):
            pt1 = w_hist[k]
            ax.scatter(pt1[0], pt1[1], 0, s=60, color=colorspec[k], edgecolor="k", linewidth=0.5 * math.sqrt((1 / (float(k) + 1))), zorder=3)
            if k < len(w_hist) - 1:
                pt2 = w_hist[k + 1]
                if np.linalg.norm(pt1 - pt2) > 10 ** (-3):
                    # draw arrow in left plot
                    a = Arrow3D([pt1[0], pt2[0]], [pt1[1], pt2[1]], [0, 0], mutation_scale=10, lw=2, arrowstyle="-|>", color="k")
                    ax.add_artist(a)


#### custom 3d arrow and annotator functions ###
# nice arrow maker from https://stackoverflow.com/questions/11140163/python-matplotlib-plotting-a-3d-cube-a-sphere-and-a-vector
class Arrow3D(FancyArrowPatch):
    def __init__(self, xs, ys, zs, *args, **kwargs):
        super().__init__((0, 0), (0, 0), *args, **kwargs)
        self._verts3d = xs, ys, zs

    def do_3d_projection(self, renderer=None):
        xs3d, ys3d, zs3d = self._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)
        self.set_positions((xs[0], ys[0]), (xs[1], ys[1]))

        return np.min(zs)
